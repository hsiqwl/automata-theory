//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : pattern_scanner.sm
//

#include "scanner.h"
#include "pattern_scanner_sm.h"

using namespace statemap;

// Static class declarations.
MainMap_start MainMap::start("MainMap::start", 0);
MainMap_second_command_after_first_token MainMap::second_command_after_first_token("MainMap::second_command_after_first_token", 1);
MainMap_reading_argument_after_join_stmt MainMap::reading_argument_after_join_stmt("MainMap::reading_argument_after_join_stmt", 2);
MainMap_finishing_second_command MainMap::finishing_second_command("MainMap::finishing_second_command", 3);
MainMap_first_command_after_first_token MainMap::first_command_after_first_token("MainMap::first_command_after_first_token", 4);
MainMap_first_command_after_first_argument MainMap::first_command_after_first_argument("MainMap::first_command_after_first_argument", 5);
MainMap_reading_argument_list MainMap::reading_argument_list("MainMap::reading_argument_list", 6);
MainMap_valid_argument_list MainMap::valid_argument_list("MainMap::valid_argument_list", 7);
MainMap_finishing_first_command MainMap::finishing_first_command("MainMap::finishing_first_command", 8);
MainMap_error MainMap::error("MainMap::error", 9);

void parserState::read_next_token(pattern_scannerContext& context, std::string& string)
{
    Default(context);
}

void parserState::Default(pattern_scannerContext& context)
{
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "TRANSITION   : Default"
            << std::endl;
    }

    throw (
        TransitionUndefinedException(
            (context.getState()).getName(),
            context.getTransition()));

}

void MainMap_Default::read_next_token(pattern_scannerContext& context, std::string& string)
{

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::Default"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "BEFORE EXIT     : MainMap::Default::Exit(context)"
            << std::endl;
    }

    context.getState().Exit(context);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "AFTER EXIT      : MainMap::Default::Exit(context)"
                << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::Default::read_next_token(std::string& string)"
            << std::endl;
    }

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "EXIT TRANSITION : MainMap::Default::read_next_token(std::string& string)"
            << std::endl;
    }

    context.setState(MainMap::error);
    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "BEFORE ENTRY    : MainMap::error::Entry(context)"
            << std::endl;
    }
    context.getState().Entry(context);

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "AFTER ENTRY     : MainMap::error::Entry(context)"
            << std::endl;
    }



}

void MainMap_start::Entry(pattern_scannerContext& context)

{
    parser& ctxt = context.getOwner();

    ctxt.invalidate();
}

void MainMap_start::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::start"
                << std::endl;
    }

    if (ctxt.scanners[1]->validate_string(string))
    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::start::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::start::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::start::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::start::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::first_command_after_first_token);
        }
        catch (...)
        {
            context.setState(MainMap::first_command_after_first_token);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::first_command_after_first_token::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::first_command_after_first_token::Entry(context)"
                << std::endl;
        }

    }
    else if (ctxt.scanners[2]->validate_string(string))

    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::start::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::start::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::start::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.validate();
            ctxt.collector.remember_argument(ctxt.move_string_to_next_token_start(string));
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::start::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::second_command_after_first_token);
        }
        catch (...)
        {
            context.setState(MainMap::second_command_after_first_token);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::second_command_after_first_token::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::second_command_after_first_token::Entry(context)"
                << std::endl;
        }

    }    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_second_command_after_first_token::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::second_command_after_first_token"
                << std::endl;
    }

    if (!string.empty() && string.find_first_of(" \t") == 0)
    {
        parserState& endState = context.getState();

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::second_command_after_first_token::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::second_command_after_first_token::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (ctxt.scanners[0]->validate_string(string))

    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::second_command_after_first_token::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::second_command_after_first_token::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::second_command_after_first_token::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.invalidate();
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::second_command_after_first_token::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::reading_argument_after_join_stmt);
        }
        catch (...)
        {
            context.setState(MainMap::reading_argument_after_join_stmt);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::reading_argument_after_join_stmt::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::reading_argument_after_join_stmt::Entry(context)"
                << std::endl;
        }

    }    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_reading_argument_after_join_stmt::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::reading_argument_after_join_stmt"
                << std::endl;
    }

    if (!string.empty() && string.find_first_of(" \t") == 0)
    {
        parserState& endState = context.getState();

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::reading_argument_after_join_stmt::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::reading_argument_after_join_stmt::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (ctxt.scanners[2]->validate_string(string))

    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::reading_argument_after_join_stmt::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::reading_argument_after_join_stmt::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::reading_argument_after_join_stmt::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.validate();
            ctxt.collector.remember_argument(ctxt.move_string_to_next_token_start(string));
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::reading_argument_after_join_stmt::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::finishing_second_command);
        }
        catch (...)
        {
            context.setState(MainMap::finishing_second_command);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::finishing_second_command::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::finishing_second_command::Entry(context)"
                << std::endl;
        }

    }    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_finishing_second_command::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::finishing_second_command"
                << std::endl;
    }

    if (!string.empty() && string.find_first_of(" \t") == 0)
    {
        parserState& endState = context.getState();

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::finishing_second_command::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::finishing_second_command::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_first_command_after_first_token::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::first_command_after_first_token"
                << std::endl;
    }

    if (!string.empty() && string.find_first_of(" \t") == 0)
    {
        parserState& endState = context.getState();

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::first_command_after_first_token::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::first_command_after_first_token::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (string.find_first_of('(') != std::string::npos && ctxt.scanners[2]->validate_string(string.substr(0,string.find_first_of('('))))

    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::first_command_after_first_token::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::first_command_after_first_token::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::first_command_after_first_token::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.collector.accumulate_key_info(ctxt.move_string_to_next_token_start(string));
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::first_command_after_first_token::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::first_command_after_first_argument);
        }
        catch (...)
        {
            context.setState(MainMap::first_command_after_first_argument);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::first_command_after_first_argument::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::first_command_after_first_argument::Entry(context)"
                << std::endl;
        }

    }    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_first_command_after_first_argument::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::first_command_after_first_argument"
                << std::endl;
    }

    if (!string.empty() && string.find_first_of(" \t") == 0)
    {
        parserState& endState = context.getState();

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::first_command_after_first_argument::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::first_command_after_first_argument::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (!string.empty() && string[0] == '(')

    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::first_command_after_first_argument::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::first_command_after_first_argument::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::first_command_after_first_argument::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::first_command_after_first_argument::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::reading_argument_list);
        }
        catch (...)
        {
            context.setState(MainMap::reading_argument_list);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::reading_argument_list::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::reading_argument_list::Entry(context)"
                << std::endl;
        }

    }    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_reading_argument_list::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::reading_argument_list"
                << std::endl;
    }

    if (!string.empty() && string.find_first_of(" \t") == 0)
    {
        parserState& endState = context.getState();

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::reading_argument_list::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::reading_argument_list::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (string.find_first_of(",)") != std::string::npos && ctxt.scanners[2]->validate_string(string.substr(0,string.find_first_of(",)"))))

    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::reading_argument_list::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::reading_argument_list::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::reading_argument_list::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.collector.accumulate_arg_info(ctxt.move_string_to_next_token_start(string));
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::reading_argument_list::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::valid_argument_list);
        }
        catch (...)
        {
            context.setState(MainMap::valid_argument_list);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::valid_argument_list::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::valid_argument_list::Entry(context)"
                << std::endl;
        }

    }    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_valid_argument_list::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::valid_argument_list"
                << std::endl;
    }

    if (!string.empty() && string.find_first_of(" \t") == 0)
    {
        parserState& endState = context.getState();

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::valid_argument_list::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::valid_argument_list::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (!string.empty() && string[0] == ',')

    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::valid_argument_list::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::valid_argument_list::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::valid_argument_list::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::valid_argument_list::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::reading_argument_list);
        }
        catch (...)
        {
            context.setState(MainMap::reading_argument_list);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::reading_argument_list::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::reading_argument_list::Entry(context)"
                << std::endl;
        }

    }
    else if (!string.empty() && string[0] == ')')

    {
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE EXIT     : MainMap::valid_argument_list::Exit(context)"
                << std::endl;
        }

        context.getState().Exit(context);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER EXIT      : MainMap::valid_argument_list::Exit(context)"
                    << std::endl;
        }

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::valid_argument_list::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.validate();
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::valid_argument_list::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(MainMap::finishing_first_command);
        }
        catch (...)
        {
            context.setState(MainMap::finishing_first_command);
            throw;
        }
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "BEFORE ENTRY    : MainMap::finishing_first_command::Entry(context)"
                << std::endl;
        }
        context.getState().Entry(context);

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "AFTER ENTRY     : MainMap::finishing_first_command::Entry(context)"
                << std::endl;
        }

    }    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_finishing_first_command::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::finishing_first_command"
                << std::endl;
    }

    if (!string.empty() && string.find_first_of(" \t") == 0)
    {
        parserState& endState = context.getState();

        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "ENTER TRANSITION: MainMap::finishing_first_command::read_next_token(std::string& string)"
                << std::endl;
        }

        context.clearState();
        try
        {
            ctxt.move_string_to_next_token_start(string);
            if (context.getDebugFlag())
            {
                std::ostream& str = context.getDebugStream();

                str << "EXIT TRANSITION : MainMap::finishing_first_command::read_next_token(std::string& string)"
                    << std::endl;
            }

            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else
    {
         MainMap_Default::read_next_token(context, string);
    }


}

void MainMap_error::Entry(pattern_scannerContext& context)

{
    parser& ctxt = context.getOwner();

    ctxt.invalidate();
    ctxt.collector.clear_info_args();
    ctxt.collector.clear_accumulated_info();
}

void MainMap_error::read_next_token(pattern_scannerContext& context, std::string& string)
{
    parser& ctxt = context.getOwner();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "LEAVING STATE   : MainMap::error"
                << std::endl;
    }

    parserState& endState = context.getState();

    if (context.getDebugFlag())
    {
        std::ostream& str = context.getDebugStream();

        str << "ENTER TRANSITION: MainMap::error::read_next_token(std::string& string)"
            << std::endl;
    }

    context.clearState();
    try
    {
        ctxt.move_string_to_next_token_start(string);
        if (context.getDebugFlag())
        {
            std::ostream& str = context.getDebugStream();

            str << "EXIT TRANSITION : MainMap::error::read_next_token(std::string& string)"
                << std::endl;
        }

        context.setState(endState);
    }
    catch (...)
    {
        context.setState(endState);
        throw;
    }


}

//
// Local variables:
//  buffer-read-only: t
// End:
//
