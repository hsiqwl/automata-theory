//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : pattern_scanner.sm
//

#ifndef PATTERN_SCANNER_SM_H
#define PATTERN_SCANNER_SM_H


#define SMC_USES_IOSTREAMS

#include <statemap.h>

// Forward declarations.
class MainMap;
class MainMap_start;
class MainMap_second_command_after_first_token;
class MainMap_reading_argument_after_join_stmt;
class MainMap_finishing_second_command;
class MainMap_first_command_after_first_token;
class MainMap_first_command_after_first_argument;
class MainMap_reading_argument_list;
class MainMap_valid_argument_list;
class MainMap_finishing_first_command;
class MainMap_error;
class MainMap_Default;
class parserState;
class pattern_scannerContext;
class parser;

class parserState :
    public statemap::State
{
public:

    parserState(const char * const name, const int stateId)
    : statemap::State(name, stateId)
    {};

    virtual void Entry(pattern_scannerContext&) {};
    virtual void Exit(pattern_scannerContext&) {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);

protected:

    virtual void Default(pattern_scannerContext& context);
};

class MainMap
{
public:

    static MainMap_start start;
    static MainMap_second_command_after_first_token second_command_after_first_token;
    static MainMap_reading_argument_after_join_stmt reading_argument_after_join_stmt;
    static MainMap_finishing_second_command finishing_second_command;
    static MainMap_first_command_after_first_token first_command_after_first_token;
    static MainMap_first_command_after_first_argument first_command_after_first_argument;
    static MainMap_reading_argument_list reading_argument_list;
    static MainMap_valid_argument_list valid_argument_list;
    static MainMap_finishing_first_command finishing_first_command;
    static MainMap_error error;
};

class MainMap_Default :
    public parserState
{
public:

    MainMap_Default(const char * const name, const int stateId)
    : parserState(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_start :
    public MainMap_Default
{
public:
    MainMap_start(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void Entry(pattern_scannerContext&);
    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_second_command_after_first_token :
    public MainMap_Default
{
public:
    MainMap_second_command_after_first_token(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_reading_argument_after_join_stmt :
    public MainMap_Default
{
public:
    MainMap_reading_argument_after_join_stmt(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_finishing_second_command :
    public MainMap_Default
{
public:
    MainMap_finishing_second_command(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_first_command_after_first_token :
    public MainMap_Default
{
public:
    MainMap_first_command_after_first_token(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_first_command_after_first_argument :
    public MainMap_Default
{
public:
    MainMap_first_command_after_first_argument(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_reading_argument_list :
    public MainMap_Default
{
public:
    MainMap_reading_argument_list(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_valid_argument_list :
    public MainMap_Default
{
public:
    MainMap_valid_argument_list(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_finishing_first_command :
    public MainMap_Default
{
public:
    MainMap_finishing_first_command(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class MainMap_error :
    public MainMap_Default
{
public:
    MainMap_error(const char * const name, const int stateId)
    : MainMap_Default(name, stateId)
    {};

    virtual void Entry(pattern_scannerContext&);
    virtual void read_next_token(pattern_scannerContext& context, std::string& string);
};

class pattern_scannerContext :
    public statemap::FSMContext
{
public:

    explicit pattern_scannerContext(parser& owner)
    : FSMContext(MainMap::start),
      _owner(owner)
    {};

    pattern_scannerContext(parser& owner, const statemap::State& state)
    : FSMContext(state),
      _owner(owner)
    {};

    virtual void enterStartState()
    {
        getState().Entry(*this);
        return;
    }

    inline parser& getOwner()
    {
        return (_owner);
    };

    inline parserState& getState()
    {
        if (_state == NULL)
        {
            throw statemap::StateUndefinedException();
        }

        return dynamic_cast<parserState&>(*_state);
    };

    inline void read_next_token(std::string& string)
    {
        setTransition("read_next_token");
        getState().read_next_token(*this, string);
        setTransition(NULL);
    };

private:
    parser& _owner;
};


#endif // PATTERN_SCANNER_SM_H

//
// Local variables:
//  buffer-read-only: t
// End:
//
